/*
 ============================================================================
 Name        : balance.c
 Author      : Daniel MÃ¥rtensson
 Version     : 1.0
 Copyright   : MIT
 Description : Balance a matrix A
 ============================================================================
 */

#include <stdio.h>
#include <stdlib.h>
#include <unity.h>
#include <control/linalg.h>
#include <control/misc.h>

void test_balance(void)
{
	// Matrix A
	float A[3 * 3] = { 1.0000e+00, 1.0000e+02, 1.0000e+04, 1.0000e-02, 1.0000e+00,
			   1.0000e+02, 1.0000e-04, 1.0000e-02, 1.0000e+00 };

	balance(A, 3);

	// Print balanced matrix A
	printf("A:\n");
	print(A, 3, 3);
}

/*
 * GNU Octave code:
 * A = [1.0000e+00   1.0000e+02   1.0000e+04
	    1.0000e-02   1.0000e+00   1.0000e+02
	    1.0000e-04   1.0000e-02   1.0000e+00];

   balance(A)
 */

void test_cholupdate(void)
{
	float L[4 * 4] = { 1, 0, 0, 0, 1, 1, 0, 0, 1, 2, 1, 0, 1, 3, 3, 1 };

	float x[4] = { 0.1, 0.2, 0.3, -1 / sqrtf(2) };

	bool rank_one_update = true; /* false = rank_one_downdate */
	cholupdate(L, x, 4, rank_one_update);

	/* Result */
	print(L, 4, 4);
}

/* GNU Octave code:
 *
	A = pascal(4);
	A = chol(A, 'lower');
	x =  [0.1;0.2;0.3;-1/sqrt(2)];
	cholupdate2(A, x, '-')  % or '-' (see the MATLAB code in cholupdate function)
 */
void test_det(void)
{
	// Matrix A
	float A[2 * 2] = { 0.798231, 0.191700, -0.575101, 0.031430 };

	float determinant = det(A, 2);

	// Print the determinant
	printf("Det of A = %f\n", determinant);
}

/*
 * GNU Octave code:
 * A = [0.798231,   0.191700,
	   -0.575101,   0.031430];

	d = det(A)
 */

void test_dlyap(void)
{
	// Matrix A
	float A[2 * 2] = { 0.798231, 0.191700, -0.575101, 0.031430 };

	// Symmetric positive matrix
	float Q[2 * 2] = { 1, 2, 2, 3 };

	// Solution for the equation A * P * A' - P + Q = 0
	float P[2 * 2];

	dlyap(A, P, Q, 2);

	// Print P - This A matrix have absolute eigenvalues less < 1 because of P > 0 and P = P^T
	printf("P\n");
	print(P, 2, 2);
}

/*
 * GNU Octave code:
 * A = [0.798231,   0.191700,
	   -0.575101,   0.031430];

	Q = [1  2,
		 2, 3];

	P = dlyap(A, Q) % Using Matavecontrol package
 */

void test_eig(void)
{
	// Matrix A
	float A[4 * 4] = { 0.018142, 0.968856, 0.151740, 0.757174, 0.017829, 0.474323,
			   0.358832, 0.970854, 0.184523, 0.063063, 0.680511, 0.191901,
			   0.806877, 0.830208, 0.977169, 0.222291 };

	float wr_a[4]; // Eigenvalues real
	float wi_a[4]; // Eigenvalues imaginary

	// Matrix B
	float B[12 * 12] = { 144, 2,   3,   141, 140, 6,   7,	137, 136, 10, 11,  133, 13,  131,
			     130, 16,  17,  127, 126, 20,  21,	123, 122, 24, 25,  119, 118, 28,
			     29,  115, 114, 32,	 33,  111, 110, 36,  108, 38, 39,  105, 104, 42,
			     43,  101, 100, 46,	 47,  97,  96,	50,  51,  93, 92,  54,	55,  89,
			     88,  58,  59,  85,	 61,  83,  82,	64,  65,  79, 78,  68,	69,  75,
			     74,  72,  73,  71,	 70,  76,  77,	67,  66,  80, 81,  63,	62,  84,
			     60,  86,  87,  57,	 56,  90,  91,	53,  52,  94, 95,  49,	48,  98,
			     99,  45,  44,  102, 103, 41,  40,	106, 107, 37, 109, 35,	34,  112,
			     113, 31,  30,  116, 117, 27,  26,	120, 121, 23, 22,  124, 125, 19,
			     18,  128, 129, 15,	 14,  132, 12,	134, 135, 9,  8,   138, 139, 5,
			     4,	  142, 143, 100 };

	float wr_b[12]; // Eigenvalues real
	float wi_b[12]; // Eigenvalues imaginary

	eig(A, wr_a, wi_a, 4);
	eig(B, wr_b, wi_b, 12);

	// Print eigenvalues
	printf("Real eigenvalues of A:\n");
	print(wr_a, 4, 1);
	printf("Imaginary eigenvalues of A: \n");
	print(wi_a, 4, 1);

	printf("Real eigenvalues of B:\n");
	print(wr_b, 12, 1);
	printf("Imaginary eigenvalues of B: \n");
	print(wi_b, 12, 1);
}

/*
 * GNU Octave code:
 * A = [0.018142,   0.968856,   0.151740,   0.757174,
		0.017829,   0.474323,   0.358832,   0.970854,
		0.184523,   0.063063,   0.680511,   0.191901,
		0.806877,   0.830208,   0.977169,   0.222291];

   B =[ 144     2     3   141   140     6     7   137   136    10    11   133
    	13   131   130    16    17   127   126    20    21   123   122    24
    	25   119   118    28    29   115   114    32    33   111   110    36
   	   108    38    39   105   104    42    43   101   100    46    47    97
    	96    50    51    93    92    54    55    89    88    58    59    85
    	61    83    82    64    65    79    78    68    69    75    74    72
    	73    71    70    76    77    67    66    80    81    63    62    84
    	60    86    87    57    56    90    91    53    52    94    95    49
    	48    98    99    45    44   102   103    41    40   106   107    37
   	   109    35    34   112   113    31    30   116   117    27    26   120
   	   121    23    22   124   125    19    18   128   129    15    14   132
    	12   134   135     9     8   138   139     5     4   142   143   100];

	eig(A)
	eig(B)
 */

void test_eig_sym(void)
{
	// Matrix A - Will become eigenvectors
	float A[5 * 5] = { 2.77099,  -1.59681, -1.43482, -2.11912, 1.36763, -1.59681, 2.63164,
			   0.39652,  1.33448,  -0.29600, -1.43482, 0.39652, 9.45852,  3.45891,
			   -1.71136, -2.11912, 1.33448,	 3.45891,  6.01772, 0.46433,  1.36763,
			   -0.29600, -1.71136, 0.46433,	 1.70259 };
	// Eigenvalues
	float d[5];

	eig_sym(A, 5, d);
	// Print eigenvalues of A
	printf("d:\n");
	print(d, 5, 1);

	// Print eigenvectors of A
	printf("A:\n");
	print(A, 5, 5);
}

/*
 * GNU Octave code:
 * A = [ 2.77099  -1.59681  -1.43482  -2.11912   1.36763;
	    -1.59681   2.63164   0.39652   1.33448  -0.29600;
	    -1.43482   0.39652   9.45852   3.45891  -1.71136;
	    -2.11912   1.33448   3.45891   6.01772   0.46433;
	     1.36763  -0.29600  -1.71136   0.46433   1.70259];

	[t, d] = eig(A)
 */

void test_hankel(void)
{
	// Output
	float V[2 * 10] = { 3, 51, 3, 2, 6, 7, 8, 9, 1, 4, 1, 3, 1, 4, 5, 1, 7, 8, 1, 10 };

	float A[1 * 10] = { 0, 2, 4, 1, 4, 5, 7, 2, 7, 8 };

	// Hankel matrix - Remember! If we want V into H and V is more then 1 row
	// then we need to increase the rows of hanekel matrix H
	float H0[(2 * 5) *
		 5]; // Half hankel matrix - Yes, that's possible too! Used in era() function
	float H1[(2 * 10) * 10]; // Normal hankel matrix
	float H2[10 * 10]; // Normal hankel matrix

	hankel(V, H0, 2, 10, 2 * 5, 5, 1); // Shift = 1
	hankel(V, H1, 2, 10, 2 * 10, 10, 0); // Shift = 0
	hankel(A, H2, 1, 10, 10, 10, 0);

	printf("Half hankel matrix:\n");
	print(H0, 2 * 5, 5);

	printf("Complete hankel matrix:\n");
	print(H1, 2 * 10, 10);

	printf("Complete hankel matrix:\n");
	print(H2, 10, 10);
}

void test_inv(void)
{
	// Matrix A
	float A[4 * 4] = { 0.018142, 0.968856, 0.151740, 0.757174, 0.017829, 0.474323,
			   0.358832, 0.970854, 0.184523, 0.063063, 0.680511, 0.191901,
			   0.806877, 0.830208, 0.977169, 0.222291 };

	// Singular matrix! Cannot use inverse!
	float B[12 * 12] = { 144, 2,   3,   141, 140, 6,   7,	137, 136, 10, 11,  133, 13,  131,
			     130, 16,  17,  127, 126, 20,  21,	123, 122, 24, 25,  119, 118, 28,
			     29,  115, 114, 32,	 33,  111, 110, 36,  108, 38, 39,  105, 104, 42,
			     43,  101, 100, 46,	 47,  97,  96,	50,  51,  93, 92,  54,	55,  89,
			     88,  58,  59,  85,	 61,  83,  82,	64,  65,  79, 78,  68,	69,  75,
			     74,  72,  73,  71,	 70,  76,  77,	67,  66,  80, 81,  63,	62,  84,
			     60,  86,  87,  57,	 56,  90,  91,	53,  52,  94, 95,  49,	48,  98,
			     99,  45,  44,  102, 103, 41,  40,	106, 107, 37, 109, 35,	34,  112,
			     113, 31,  30,  116, 117, 27,  26,	120, 121, 23, 22,  124, 125, 19,
			     18,  128, 129, 15,	 14,  132, 12,	134, 135, 9,  8,   138, 139, 5,
			     4,	  142, 143, 1 };

	int status = inv(A, 4);
	printf("Status on matrix A(1 == success, 0 == fail): %d\n", status);
	status = inv(B, 12);
	printf("Status on matrix B(1 == success, 0 == fail): %d\n", status);

	// Print A
	printf("A^(-1)\n");
	print(A, 4, 4);
}

/*
 * GNU Octave code:
 * A = [0.018142,   0.968856,   0.151740,   0.757174,
		0.017829,   0.474323,   0.358832,   0.970854,
		0.184523,   0.063063,   0.680511,   0.191901,
		0.806877,   0.830208,   0.977169,   0.222291];

   B =[ 144     2     3   141   140     6     7   137   136    10    11   133
    	13   131   130    16    17   127   126    20    21   123   122    24
    	25   119   118    28    29   115   114    32    33   111   110    36
   	   108    38    39   105   104    42    43   101   100    46    47    97
    	96    50    51    93    92    54    55    89    88    58    59    85
    	61    83    82    64    65    79    78    68    69    75    74    72
    	73    71    70    76    77    67    66    80    81    63    62    84
    	60    86    87    57    56    90    91    53    52    94    95    49
    	48    98    99    45    44   102   103    41    40   106   107    37
   	   109    35    34   112   113    31    30   116   117    27    26   120
   	   121    23    22   124   125    19    18   128   129    15    14   132
    	12   134   135     9     8   138   139     5     4   142   143     1];

	Ainv = inv(A)
	Binv = inv(B)
 */

void test_linsolve_chol(void)
{
	// Matrix A
	float A[5 * 5] = { 1.1000,  2.0000,  3.0000,  4.0000,  5.0000,	2.0000,	 4.1000,
			   6.0000,  8.0000,  10.0000, 3.0000,  6.0000,	9.1000,	 12.0000,
			   15.0000, 4.0000,  8.0000,  12.0000, 16.1000, 20.0000, 5.0000,
			   10.0000, 15.0000, 20.0000, 25.1000 };

	// Vector b
	float b[5] = { 5, 3, 2, 5, 7 };

	// Solution that need to have the same rows and columns from A
	float x[5];

	// Do Cholesky decomposition and then solve with linsolve_chol
	linsolve_chol(A, x, b, 5);

	// Print x
	printf("x\n");
	print(x, 5, 1);
}

/*
 * GNU Octave code:
 * A = [1.1000    2.0000    3.0000    4.0000    5.0000
        2.0000    4.1000    6.0000    8.0000   10.0000
        3.0000    6.0000    9.1000   12.0000   15.0000
        4.0000    8.0000   12.0000   16.1000   20.0000
        5.0000   10.0000   15.0000   20.0000   25.1000];

   b = [5; 3; 2; 5; 7];

   x = linsolve(A, b)
 *
 */

void test_linsolve_gauss(void)
{
	// Matrix A
	float A[6 * 4] = { 0.9889143, 0.8156388, 0.7197012, 0.9117410, 0.3513571, 0.9509832,
			   0.7666883, 0.2984587, 0.7419696, 0.6665918, 0.8349609, 0.0493249,
			   0.5387147, 0.9922028, 0.7225777, 0.1423897, 0.0217779, 0.5598255,
			   0.5004498, 0.5730017, 0.9608793, 0.4709475, 0.0031274, 0.0698641 };

	// Vector b
	float b[6] = { 0.883369, 0.653627, 0.417359, 0.049459, 0.879004, 0.152040 };

	// Solution that need to have the same rows and columns from A
	float x[4];

	// If we are using alpha = 0, then matrix A MUST be square!
	float alpha = 0.1;

	linsolve_gauss(A, x, b, 6, 4, alpha);

	printf("x\n");
	print(x, 4, 1);
}

/*
 * GNU Octave code:
 * A = [0.9889143,   0.8156388,   0.7197012,   0.9117410,
	    0.3513571,   0.9509832,   0.7666883,   0.2984587,
		0.7419696,   0.6665918,   0.8349609,   0.0493249,
		0.5387147,   0.9922028,   0.7225777,   0.1423897,
	    0.0217779,   0.5598255,   0.5004498,   0.5730017,
		0.9608793,   0.4709475,   0.0031274,   0.0698641];

	b = [0.883369,
	     0.653627,
		 0.417359,
		 0.049459,
		 0.879004,
		 0.152040];

	alpha = 0.1;
    x = inv(A'*A + eye(size(A'*A))*alpha)*A'*b
 *
 */

void test_linsolve_lup(void)
{
	// Matrix A
	float A[4 * 4] = { 0.47462, 0.74679, 0.31008, 0.63073, 0.32540, 0.49584, 0.50932, 0.21492,
			   0.43855, 0.98844, 0.54041, 0.24647, 0.62808, 0.72591, 0.20244, 0.96743 };

	// Vector b
	float b[4] = { 1.588964, 0.901248, 0.062029, 0.142180 };

	// Solution that need to have the same rows and columns from A
	float x[4];

	// Do LUP-decomposition and then solve with linsolve_lup
	int status = linsolve_lup(A, x, b, 4);

	// Print x
	printf("x\n");
	print(x, 4, 1);

	printf("Status(1 == success, 0 == fail): %d", status);
}

/*
 * GNU Octave code:
 * A = [0.47462,   0.74679,   0.31008,   0.63073,
		0.32540,   0.49584,   0.50932,   0.21492,
		0.43855,   0.98844,   0.54041,   0.24647,
		0.62808,   0.72591,   0.20244,   0.96743];

	b = [1.588964,
		 0.901248,
		 0.062029,
		 0.142180];

	x = linsolve(A, b)
 *
 */

void test_linsolve_qr(void)
{
	// Matrix A
	float A[6 * 4] = { 0.9889143, 0.8156388, 0.7197012, 0.9117410, 0.3513571, 0.9509832,
			   0.7666883, 0.2984587, 0.7419696, 0.6665918, 0.8349609, 0.0493249,
			   0.5387147, 0.9922028, 0.7225777, 0.1423897, 0.0217779, 0.5598255,
			   0.5004498, 0.5730017, 0.9608793, 0.4709475, 0.0031274, 0.0698641 };

	// Vector b
	float b[6] = { 0.883369, 0.653627, 0.417359, 0.049459, 0.879004, 0.152040 };

	// Solution that need to have the same rows and columns from A
	float x[4];

	linsolve_qr(A, x, b, 6, 4);

	printf("x\n");
	print(x, 4, 1);
}

/*
 * GNU Octave code:
 * A = [0.9889143,   0.8156388,   0.7197012,   0.9117410,
	    0.3513571,   0.9509832,   0.7666883,   0.2984587,
		0.7419696,   0.6665918,   0.8349609,   0.0493249,
		0.5387147,   0.9922028,   0.7225777,   0.1423897,
	    0.0217779,   0.5598255,   0.5004498,   0.5730017,
		0.9608793,   0.4709475,   0.0031274,   0.0698641];

	b = [0.883369,
	     0.653627,
		 0.417359,
		 0.049459,
		 0.879004,
		 0.152040];

	[Q,R] = qr(A)
	x = linsolve(R, Q'*b)
 *
 */

#if 0
void _mul_at_bc(void)
{
	float A[10 * 6] = { -0.433394, 0.278422,  -1.023816, -0.685246, -2.522174, 1.519773,
			    0.436349,  0.090482,  -0.937444, 0.779249,	-0.939243, -1.913526,
			    2.774075,  -1.255168, 0.207749,  0.191749,	0.792312,  -0.201041,
			    1.079424,  -0.809794, 0.343935,  0.255140,	-0.390280, 0.346842,
			    0.813631,  -1.169705, 0.154307,  0.544002,	-0.773535, 0.983982,
			    1.721245,  0.307763,  0.056856,  0.655271,	0.931621,  0.486039,
			    1.273108,  0.195401,  0.267128,  3.815890,	-1.441082, 0.675211,
			    0.696080,  -0.078450, -2.167726, -0.739348, -0.682215, -0.327527,
			    -0.260960, 0.334609,  0.538043,  -0.108593, 0.813089,  3.101853,
			    -0.535003, -1.104550, -1.891203, 1.632075,	0.104577,  1.537092 };

	float B[10 * 5] = { 0.365538,  0.819696,  -0.678377, 0.455721,	0.550668,  -0.124906,
			    0.105643,  0.370907,  1.599701,  0.853579,	-0.303399, 0.320718,
			    -0.030259, -0.246887, -0.237819, 0.245086,	-0.204492, 0.102836,
			    -0.252448, -0.498743, -0.736376, 0.257135,	0.883968,  0.347229,
			    0.799271,  -0.209417, -0.448321, -0.017691, -1.995118, -1.243968,
			    0.699636,  0.640878,  0.586330,  0.914712,	-0.387452, -0.565452,
			    0.393734,  0.635644,  -0.259368, -0.895053, 0.324667,  2.224340,
			    0.518273,  -1.436725, 1.042484,  -1.811828, -0.905678, -1.506752,
			    2.188069,  -1.453681 };

	float C[5 * 8] = { -1.301195, -0.783157, 1.927534,  0.389120,  -0.036835, -1.009216,
			   -1.866301, 0.149224,	 -1.058109, 1.063686,  -0.619591, -0.259768,
			   2.568637,  1.621733,	 -0.867414, 1.670795,  0.741944,  -1.598556,
			   -0.046425, 0.196823,	 -0.673001, 0.215687,  -0.793841, -1.996422,
			   -0.548508, 0.499263,	 0.984509,  -0.862646, -1.879741, -1.042061,
			   -1.294193, 0.674749,	 -0.049338, -0.042436, 0.693322,  0.074111,
			   -0.241436, 1.433374,	 1.943334,  -0.720840 };

	float D[6 * 8];

	tran(A, 10, 6);
	mul_at_bc(A, B, C, D, 10, 6, 5, 8); // Do D = A'*B*C
	tran(A, 6, 10); // If we want to have it back

	printf("Matrix: D:\n");
	print(D, 6, 8);
}

#endif
/*
 * GNU Octave code:
 * D = A'*B*C
 */

void test_nonlinsolve(void)
{
	// Initial parameters
	uint8_t elements = 3;
	bool random_guess_active = true;
	float x[3] = { 0, 0, 0 }; // This is our initial guess if random_guess_active = false
	float dx[3] = { 0, 0, 0 };
	float b[3] = { 1, 1, 1 };
	// Min max is only for random_guess_active
	float min_value = -5;
	float max_value = 5;
	float alpha = 0.05; // A smal positive number for tuning
	/* Create a function on the form dx = Ax - b
	 * b can contains ones if you want.
	 * A need to be square, but can still have zero rows, the same for dx
	 */
	void func(float *dx, float *b, float *x)
	{
		dx[0] = 5 * x[0] + 2 * x[1] * x[2] + 9 * x[2] * x[2] - 50 * b[0];
		dx[1] = 10 * x[0] * x[1] * x[1] + 6 * x[1] - 3 * x[2] - 7 * b[1];
		dx[2] = 0 * x[0] - 0 * x[1] + 0 * x[2] - 0 * b[0];
	}

// Start clock
// Do the process with random guess active
start:
	nonlinsolve(func, b, x, elements, alpha, max_value, min_value, random_guess_active);
	printf("Solution to func with random_guess_active = true:\n");
	print(x, 1, elements);
	func(dx, b, x);
	float accuracy = norm(dx, 1, elements, 2);
	printf("Accuracy(lower = better): %0.18f\n", accuracy);
	if (accuracy > 0.001) {
		printf("Try again, the accuracy was too low\n\n");
		goto start;
	}

	// Do the process with random guess active
	random_guess_active = false;
	x[0] = 1;
	x[1] = 1;
	x[2] = 1;
	alpha = 0.01;
	nonlinsolve(func, b, x, elements, alpha, max_value, min_value, random_guess_active);
	printf("Solution to func with random_guess_active = false:\n");
	print(x, 1, elements);
	func(dx, b, x);
	printf("Accuracy(lower = better): %0.18f\n", norm(dx, 1, elements, 2));
}

void test_pinv(void)
{
	float A[10 * 5] = { -0.826584, 1.075993,  -0.069268, -0.146931, 0.185104,  0.040081,
			    0.135270,  0.339906,  0.098106,  -1.655800, -0.521739, 0.061760,
			    -0.281359, 1.250549,  -1.595000, 0.575910,	-0.757662, -1.381349,
			    -0.695297, 0.089007,  -0.086319, 1.248045,	-0.547583, -0.202141,
			    0.880217,  0.829765,  0.569914,  -0.513688, 1.473023,  1.255679,
			    -0.275721, -0.235370, 0.885980,  0.980984,	0.792136,  -0.734654,
			    0.832280,  0.802771,  -0.457511, 0.932049,	-0.306556, -1.135363,
			    -0.724773, -0.154853, -1.197430, -0.716699, -1.085080, 1.056329,
			    1.011706,  0.439173 };

	float B[5 * 5] = { -0.882436, -1.466448, 0.097115,  -0.484182, -0.644157,
			   0.364987,  0.438386,	 -0.026300, -1.174605, 0.490712,
			   -0.968832, -0.807293, -1.051890, 0.588022,  -0.013745,
			   1.544502,  -0.061614, -0.030349, 0.522773,  -1.165337,
			   -0.448577, 0.367060,	 -0.139004, -0.479703, -0.432461 };

	// When row > column
	pinv(A, 10, 5);
	printf("A:\n");
	print(A, 5, 10);

	// When row == column
	pinv(B, 5, 5);
	printf("B:\n");
	print(B, 5, 5);
}

void test_qr(void)
{
	/* Create A matrix */
	float A[9 * 3] = {
		0.000000000000000000,  0.000000000000000000,  0.035355340689420700,
		0.707106769084930420,  0.000000000000000000,  0.000000000000000000,
		0.000000000000000000,  0.707106828689575200,  0.000000000000000000,
		0.000000000000000000,  0.000000000000000000,  -0.035355340689420700,
		-0.707106769084930420, 0.000000000000000000,  0.000000000000000000,
		0.000000000000000000,  -0.707106828689575200, 0.000000000000000000,
		0.100000001490116120,  0.000000000000000000,  0.000000000000000000,
		0.000000000000000000,  0.100000001490116120,  0.000000000000000000,
		0.000000000000000000,  0.000000000000000000,  0.100000001490116120,
	};

	/* Create Q and R matrices */
	float Q[9 * 9];
	float R[9 * 3];

	/* Q*R = A */
	qr(A, Q, R, 9, 3, false);

	/* Print Q */
	print(Q, 9, 9);

	/* Print R */
	print(R, 9, 3);
}

void test_golub_reinsch(void)
{
	// Matrix A
	float A[6 * 4] = { 0.7179787, 0.7985186, 0.1000046, 0.2203064, 0.9044292, 0.5074379,
			   0.3539301, 0.9475452, 0.0029252, 0.4930148, 0.3209303, 0.5289174,
			   0.6546133, 0.7354447, 0.9989453, 0.0310190, 0.7434944, 0.0874402,
			   0.3388867, 0.8256180, 0.7483093, 0.3624991, 0.2039784, 0.5528368 };

	float U[6 * 4];
	float S[4];
	float V[4 * 4];

	// Do SVD with Golub Reinsch method
	uint8_t status = svd_golub_reinsch(A, 6, 4, U, S, V);

	// Print U
	printf("U\n");
	print(U, 6, 4);

	// Print U
	printf("S\n");
	print(S, 4, 1);

	// Print V
	printf("V\n");
	print(V, 4, 4);

	// Print A
	printf("A\n");
	print(A, 6, 4);

	// Print status
	printf("Status is(1 = success, 0 = fail): %d\n", status);
}

/*
 * GNU Octave code:
 * A = [0.7179787,   0.7985186,   0.1000046,   0.2203064,
		0.9044292,   0.5074379,   0.3539301,   0.9475452,
		0.0029252,   0.4930148,   0.3209303,   0.5289174,
		0.6546133,   0.7354447,   0.9989453,   0.0310190,
		0.7434944,   0.0874402,   0.3388867,   0.8256180,
		0.7483093,   0.3624991,   0.2039784,   0.5528368];

   [U, S, V] = svd(A)
 */

void test_jacobi_one_sided(void)
{
	// Matrix A
	float A[4 * 4] = { 0.453690, 0.866686, 0.579250, 0.418100, 0.059901, 0.954740,
			   0.699338, 0.681427, 0.127995, 0.981347, 0.713651, 0.485167,
			   0.269875, 0.723569, 0.778578, 0.130682 };

	float U[4 * 4];
	float S[4];
	float V[4 * 4];

	// Do SVD with one-sided jacobi
	svd_jacobi_one_sided(A, 4, 10, U, S, V); // 10 Iterations

	// Print U
	printf("U\n");
	print(U, 4, 4);

	// Print U
	printf("S\n");
	print(S, 4, 1);

	// Print V
	printf("V\n");
	print(V, 4, 4);
}

/*
 * GNU Octave code:
 * A = [0.453690,   0.866686,   0.579250,   0.418100,
	    0.059901,   0.954740,   0.699338,   0.681427,
		0.127995,   0.981347,   0.713651,   0.485167,
		0.269875,   0.723569,   0.778578,   0.130682];

   [U, S, V] = svd(A)
 */
